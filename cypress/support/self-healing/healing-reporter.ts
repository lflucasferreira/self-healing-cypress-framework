import { HealingEvent, HealingReport, HealingSummary, LocatorType } from './types'
import { locatorStore } from './locator-store'

/**
 * Generates comprehensive healing reports
 */
export class HealingReporter {
  /**
   * Generates a full healing report
   */
  generateReport(): HealingReport {
    const events = locatorStore.getHealingEvents()

    return {
      generatedAt: new Date(),
      totalTests: this.countUniqueTests(events),
      totalHealingEvents: events.length,
      events,
      summary: this.generateSummary(events),
    }
  }

  /**
   * Generates a summary of healing events
   */
  private generateSummary(events: HealingEvent[]): HealingSummary {
    const byStrategy: Record<string, number> = {}
    const byElement: Record<string, number> = {}
    let totalConfidence = 0

    events.forEach((event) => {
      // Count by strategy
      byStrategy[event.strategy] = (byStrategy[event.strategy] || 0) + 1

      // Count by element
      byElement[event.elementName] = (byElement[event.elementName] || 0) + 1

      // Sum confidence
      totalConfidence += event.confidence
    })

    return {
      byStrategy: byStrategy as Record<LocatorType, number>,
      byElement,
      averageConfidence: events.length > 0 ? totalConfidence / events.length : 0,
      successRate: 1, // All recorded events are successful healings
    }
  }

  /**
   * Counts unique tests that had healing events
   */
  private countUniqueTests(events: HealingEvent[]): number {
    const uniqueTests = new Set(events.map((e) => `${e.testFile}:${e.testName}`))
    return uniqueTests.size
  }

  /**
   * Formats a healing event for console output
   */
  formatEventForConsole(event: HealingEvent): string {
    return `
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  ðŸ”§ SELF-HEALING ACTIVATED                                      â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  Element:    ${event.elementName.padEnd(47)}â•‘
â•‘  Original:   ${event.originalLocator.substring(0, 47).padEnd(47)}â•‘
â•‘  Healed to:  ${event.healedLocator.substring(0, 47).padEnd(47)}â•‘
â•‘  Strategy:   ${event.strategy.padEnd(47)}â•‘
â•‘  Confidence: ${(event.confidence * 100).toFixed(1).padEnd(46)}%â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    `.trim()
  }

  /**
   * Generates a markdown report
   */
  generateMarkdownReport(): string {
    const report = this.generateReport()
    const { summary } = report

    let markdown = `# ðŸ”§ Self-Healing Test Report

**Generated:** ${report.generatedAt.toISOString()}

## Summary

| Metric | Value |
|--------|-------|
| Total Healing Events | ${report.totalHealingEvents} |
| Tests Affected | ${report.totalTests} |
| Average Confidence | ${(summary.averageConfidence * 100).toFixed(1)}% |

## Healing by Strategy

| Strategy | Count |
|----------|-------|
`

    Object.entries(summary.byStrategy)
      .sort(([, a], [, b]) => b - a)
      .forEach(([strategy, count]) => {
        markdown += `| ${strategy} | ${count} |\n`
      })

    markdown += `

## Most Frequently Healed Elements

| Element | Heal Count |
|---------|------------|
`

    Object.entries(summary.byElement)
      .sort(([, a], [, b]) => b - a)
      .slice(0, 10)
      .forEach(([element, count]) => {
        markdown += `| ${element} | ${count} |\n`
      })

    if (report.events.length > 0) {
      markdown += `

## Recent Healing Events

| Timestamp | Element | Original â†’ Healed | Confidence |
|-----------|---------|-------------------|------------|
`

      report.events.slice(-10).forEach((event) => {
        const time = new Date(event.timestamp).toISOString().split('T')[1].split('.')[0]
        markdown += `| ${time} | ${event.elementName} | \`${event.originalLocator.substring(0, 20)}\` â†’ \`${event.healedLocator.substring(0, 20)}\` | ${(event.confidence * 100).toFixed(0)}% |\n`
      })
    }

    markdown += `

---
*Report generated by Self-Healing Cypress Framework*
`

    return markdown
  }
}

export const healingReporter = new HealingReporter()

